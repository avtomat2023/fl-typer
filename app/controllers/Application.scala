package controllers

import play.api._
import play.api.mvc._
import play.api.libs.json._

import parsing.FLParser
import proofdiagram.ProofDiagram
import visual.Richtext

/** Controller class for Play Framework. */
class Application extends Controller {
  /** Returns an HTML responce of index HTML. */
  def index = Action {
    Ok(views.html.main())
  }

  /** Respond to typing requests.
    *
    * Clients request typing by giving expressions as Strings.
    *
    * The responce is a JSON which contains the following field:
    *   - "parsed": Boolean<br>
    *     represents if parsing succeeded.
    *
    * it also contains the following fields when the value of "parsed" is true:
    *   - "expr": Object (see [[visual.Richtext]])<br>
    *     represents the requested expression.
    *   - "type": Object (see [[visual.Richtext]])<br>
    *     represents the inferred principal type or error message.
    *   - "ast": Object (see [[visual.Ast]])<br>
    *     represents the abstract syntax tree of the requested expression.
    *   - "proof": Object (see [[visual.ProofDiagram]])<br>
    *     represents the proof diagram.
    *   - "unification": Array (see [[visual.Equations]])<br>
    *     represents all unification equations.
    * Representations of proof diagram and unification will probably be changed.
    *
    * Otherwise, it also contains the following field:
    *   - "error": String<br>
    *     represents an error message generated by the parser.
    */
  def typing(expr: String) = Action { implicit request =>
    FLParser.parse(expr) match {
      case FLParser.Success(ast, _) => {
        val diagram = ProofDiagram.make(ast)
        val unification = diagram.unification
        val unificationVisual = unification.toVisual
        val typeVisual =
          if (diagram.isFreeVariableError)
            Richtext("ill-typed: free variable reference")
          else
            unification.solve().toVisual

        Ok(JsObject(Seq(
          "parsed" -> JsBoolean(true),
          "expr" -> ast.toVisualExpr.toJSON,
          "type" -> typeVisual.toJSON,
          "ast" -> ast.toVisualAst.toJSON,
          "proof" -> diagram.toVisual.toJSON,
          "unification" -> unificationVisual.toJSON
        )))
      }
      case FLParser.NoSuccess(msg, next) => Ok(JsObject(Seq(
        "parsed" -> JsBoolean(false),
        "error" -> JsString("character " + next.pos.column + ": " + msg + "\n" +
                            next.pos.longString)
      )))
    }
  }
}
